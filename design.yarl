
channel BusCh {
    
    typedef logic[ADR_WIDTH-1:0] address_t;
    typedef logic[DAT_WIDTH-1:0] data_t;

    address_t  Addr;
    data_t OutData;
    data_t InData;
    logic req;
    logic wen;
    logic ack;

    port master{ 
        output Addr;
        output OutData;
        input  InData;
        output req;
        output wen;
        input  ack;
    }

    port slave{
        input master.OutData  InData;  // alias
        output master.InData  OutData; // alias
        output ack;
        // not defined signals are enable implicitly as input
    }

    port monitor{
        // not defined signals are enable implicitly as input
    }
}


channel MemIfCh {
    typedef BusCh.address_t address_t;
    typedef BusCh.data_t data_t;

    logic en;
    logic write;
    logic ack;
    address_t Addr;
    data_t OutData;
    data_t InData;

    port master{ 
        output en;
        output write;
        input ack;
        output  Addr;
        output  OutData;
        input InData;
        
        function void write(address_t addr, data_t data ) 
        {
            en      = 1;
            write   = 1;
            Addr    = addr;
            OutData = data;
            wait(ack);
            en      = 0;
        }
        function void read(address_t addr, function(data_t tata) cb)
        {
            en = 1;
            write = 0;
            Addr = addr;
            wait(ack);
            wait(cb(InData));
        }
        function data_t read(address_t addr)
        {
            en = 1;
            write = 0;
            Addr = addr;
            wait(ack);
            return InData;
        }
    }

    port slave{
        input master.OutData InData;
        output master.InData OutData;
        output ack;
    }
    
    port monitor{}
}


// same as Bridge = module(...)
module Bridge(input clk,
              input rst,
              BusCh.slave bus,  // channel are flatten in Verilog
              MemIfCh.master mem)
{
    logic [11:0] count;
    state s(clk.posedge || rst);

    //always and, always_comb are instantiated 

    event(s) {
        if(~rst) {
            reset();
            count = 0;
        } else {
            main();
            count += 1;
        }
    }
    
    function reset() {
        bus.ack     = 0;
        bus.OutData = 0;
        mem.en      = 0;
        mem.Addr    = 0;
        mem.OutData = 0;
        mem.write   = 0;
        s.init();  // method call replaced with other logic, insertion
    }

    function main() { // in fsm, wait and yield statement allowed, generated state machine and some combinational function
        wait(bus.req);
        if(bus.wen) {
            bus.ack = 1;
            mem.write(bus.Addr, bus.InData);
        }
        else {
            // closure style
            mem.read(bus.Addr, function(data) {
                    bus.OutData = data;
                    bus.ack     = 1;
                });
            // async/await style with wait statement
            bus.OutData = wait(mem.read(bus.Addr));
            bus.ack     = 1;
        }
    }

    logic [10:0] X;
    logic [10:0] Y;
    logic [10:0] Z;
    event {  // combinational
        Z = X + Y;
    }

    function foo(input [10:0]X, input [10:0] Y) { // same as foo = function(X,Y)
        return X + Y;
    }
    event {
        Z = foo(X,Y);
    }
}


// same as Top = module(...)
module Top(input clk,
           input rst,
           BusCh.slave bus,
           MemIfCh.master mem)
{
    logic delay_en;

    // same as b1 = Bridge(clk,rst,bus,mem)
    Bridge b1(clk, rst, 
              BusCh.slave(.Addr(bus.Addr), // channel instantiation creates new channel connection
                          .OutData(bus.OutData), 
                          .InData(bus.InData),
                          .req(bus.req), 
                          .en(delay_en),
                          .ack(bus.ack) ),
              mem);
    
    event(clk.posedge) {
        delay_en = bus.wen;
    }
}
